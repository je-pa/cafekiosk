# 더 좋은 테스트를 위한 
## Test Fixture

> 📌 Fixture: 고정물, 고정되어 있는 물체
> 
> 📌 Test Fixture: 테스트 목적, 환경을 위해 원하는 상태 값으로 고정시킨 일련의 객체

given 절에서 생성했던 모든 객체들을 의미한다고 볼 수 있다.

given 절을 구성할 때 고려할 것들에 대해 알아보자.

### setup: BeforeAll, BeforeEach
일반 코드를 작성할 때는 중복 코드를 제거하는 것이 좋지만 
픽스처들은 테스트들의 결합도에 영향을 주기 때문에 공유 변수는 지양할 것을 권한다.

```java
  @BeforeAll
  static void beforeAll(){
    // before class(테스트 클래스 전체 실행 전에 동작)
  }

  @BeforeEach
  void setUp(){
    // before method(테스트 메서드 전에 동작)
    // 각 테스트 입장에서 봤을 때 아예 몰라도 테스트 내용을 이해하는데 문제가 없는가?
    // 수정해도 모든 테스트에 영향을 주지 않는가?
  }
```
그럼 BeforeAll BeforeEach는 언제 사용할까?

1. 각 테스트 입장에서 봤을 때 아예 몰라도 테스트 내용을 이해하는데 문제가 없는가?
2. 수정해도 모든 테스트에 영향을 주지 않는가?

를 만족하면 beforeEach를 사용해도 된다고 생각하면 된다.

예를들어, 해당 클래스에서 사용하는 객체를 생성할 때 꼭 필요한 관계 매핑된 다른 엔티티가 있고, 
그 엔티티를 해당 테스트하는데 전혀 사용하지 않는다면 사용할 수 있을 것이다.(= 생성만 되면 값이 바뀌어도 문제 없음)


### data.sql
테스트도 sql 파일을 이용해 테스트 전에 데이터를 삽입하고 시작할 수 있다.
- 문제점
  1. 파편화
      - data.sql를 이용해 insert 하면 결국 테스트가 파편화가 일어난다.
      (ex.테스트 코드 문서만 봤을 때는 기본데이터가 없는데 알고보면 data.sql에 있는 점)
  2. 프로젝트가 커질수록 sql이 많아진다.
     - 데이터 구조가 바뀔 수 있다. ➡ sql을 찾아 다 바꿔주어야함
     - 유지보수 문제가 생긴다. 
  3. 테스트 코드에서 직접 생성하면 해당 테스트 클래스 내에서 필요한 필드만 구성할 수 있는 장점이 사라진다. 


### 모든 Fixture 빌더가 모여있는 추상 클래스
테스트 패키지 전체에서 사용하는 하나의 추상클래스를 만들어 모든 Fixture 빌더들을 모아놓는다면?

파라미터 값들이 매번 달라지기 때문에 새로운 빌더가 계속 생길 수 있다.

이렇게 되면 각자 필요한 빌더를 만들게 될 것이고 관리가 어려워 질 수 있다.

